# Start of HEAD
import json
import string
import sys

# End of HEAD


# Start of BODY
'''
TestStruct::
testcase_id                   [int] ID of the test-case
testcase_input_path           [str] File path to test-case input
testcase_output_path          [str] File path to test-case output generated by the problem solver
testcase_expected_output_path [str] File path to test-case expected output to be matched with
metadata_file_paths           [list<str>] File paths to Question metadata (Extra files usually used for defining traning sets)
submission_code_path          [str] File path to submission source code
testcase_result               [bool] Set to True if test-case output matches test-case expected output. Matching is done line by line
testcase_signal               [int] Exit code of the test-case process
testcase_time                 [float] Time taken by the test-case process in seconds
testcase_memory               [int] Peak memory of the test-case process determined in bytes
data                          [str] <Future use>
ResultStruct::
result      [bool]  Assign test-case result. True determines success. False determines failure
score       [float] Assign test-case score. Normalized between 0 to 1
message     [str] Assign test-case message. This message is visible to the problem solver
'''

import requests
import os

# API Configuration
API_BASE_URL = "https://api.sandbox.transferwise.tech"
API_TOKEN = os.environ.get('TRANSFERWISE_API_TOKEN', '')


def read_input_data(input_path):
    """Read and parse input JSON file"""
    try:
        with open(input_path, 'r') as f:
            data = json.load(f)
        return data
    except Exception as e:
        print(f"Unexpected error reading input data from {input_path} - {str(e)}")
        return None


def get_quote_from_api(profile_id, quote_id):
    """Fetch quote from API"""
    try:
        url = f"{API_BASE_URL}/v3/profiles/{profile_id}/quotes/{quote_id}"
        headers = {
            'Authorization': f'Bearer {API_TOKEN}'
        }
        response = requests.get(url, headers=headers, timeout=10)

        if response.status_code == 200:
            return response.json(), None
        else:
            return None, f"API returned status code {response.status_code} with message {response.text}"
    except Exception as e:
        return None, str(e)


def check_quote(profile_id, quote_id):
    """Verify quote exists"""
    result = ResultStruct()

    if not profile_id:
        result.result = False
        result.score = 0.0
        result.message = "[Quote Check] [FAIL] Submitted Profile ID is empty"
        return result, None

    if not quote_id:
        result.result = False
        result.score = 0.0
        result.message = "[Quote Check] [FAIL] Submitted Quote ID is empty"
        return result, None

    quote_data, error = get_quote_from_api(profile_id, quote_id)

    if error:
        result.result = False
        result.score = 0.0
        result.message = f"[Quote Check] [FAIL] Failed to fetch quote: {error}"
        return result, None

    result.result = True
    result.score = 1.0
    result.message = f"[Quote Check] [PASS] Quote {quote_id} exists"
    return result, quote_data


def check_receive_amount(quote_data, submitted_receive_amount):
    """Verify receive amount matches"""
    result = ResultStruct()

    if not quote_data:
        result.result = False
        result.score = 0.0
        result.message = "[Receive Amount Check] [FAIL] Quote data not available"
        return result

    try:
        target_amount = quote_data.get('targetAmount')
        target_currency = quote_data.get('targetCurrency')

        if target_amount is None or target_currency is None:
            result.result = False
            result.score = 0.0
            result.message = "[Receive Amount Check] [FAIL] Target amount or currency not found in quote data"
            return result

        actual_receive_amount = f"{target_amount} {target_currency}"

        if actual_receive_amount == submitted_receive_amount:
            result.result = True
            result.score = 1.0
            result.message = f"[Receive Amount Check] [PASS] Receive amount matches: {actual_receive_amount}"
        else:
            result.result = False
            result.score = 0.0
            result.message = f"[Receive Amount Check] [FAIL] Receive amount mismatch. " \
                             f"Submitted: {submitted_receive_amount}, Actual: {actual_receive_amount}"

        return result

    except Exception as e:
        result.result = False
        result.score = 0.0
        result.message = f"[Receive Amount Check] [FAIL] Unexpected error checking receive amount: {str(e)}"
        return result


def check_exchange_rate(quote_data, submitted_fx_rate):
    """Verify exchange rate matches"""
    result = ResultStruct()

    if not quote_data:
        result.result = False
        result.score = 0.0
        result.message = "[FX Rate Check] [FAIL] Quote data not available"
        return result

    try:
        actual_rate = quote_data.get('rate')

        if actual_rate is None:
            result.result = False
            result.score = 0.0
            result.message = "[FX Rate Check] [FAIL] Exchange rate not found in quote"
            return result

        if str(submitted_fx_rate) == str(actual_rate):
            result.result = True
            result.score = 1.0
            result.message = f"[FX Rate Check] [PASS] Exchange rate matches: {actual_rate}"
        else:
            result.result = False
            result.score = 0.0
            result.message = f"[FX Rate Check] [FAIL] Exchange rate mismatch. " \
                             f"Submitted: {submitted_fx_rate}, Actual: {actual_rate}"

        return result

    except Exception as e:
        result.result = False
        result.score = 0.0
        result.message = f"[FX Rate Check] [FAIL] Unexpected error checking exchange rate: {str(e)}"
        return result


def check_total_fee(quote_data, submitted_total_fee):
    """Verify total fee matches"""
    result = ResultStruct()

    if not quote_data:
        result.result = False
        result.score = 0.0
        result.message = "[Total Fee Check] [FAIL] Quote data not available"
        return result

    try:
        payment_options = quote_data.get('paymentOptions', [])

        if not payment_options or len(payment_options) == 0:
            result.result = False
            result.score = 0.0
            result.message = "[Total Fee Check] [FAIL] No payment options found in quote"
            return result

        first_option = payment_options[0]
        fee_info = first_option.get('fee', {})
        total_fee = fee_info.get('total')
        # source_currency = first_option.get('sourceCurrency')

        # if total_fee is None or source_currency is None:
        if total_fee is None:
            result.result = False
            result.score = 0.0
            result.message = "[Total Fee Check] [FAIL] Total fee not found in payment options"
            return result

        # actual_total_fee = f"{total_fee} {source_currency}"

        # if actual_total_fee == expected_total_fee:
        if total_fee == submitted_total_fee:
            result.result = True
            result.score = 1.0
            result.message = f"[Total Fee Check] [Pass] Total fee matches: {total_fee}"
        else:
            result.result = False
            result.score = 0.0
            result.message = f"[Total Fee Check] [FAIL] Total fee mismatch. " \
                             f"Submitted: {submitted_total_fee}, Actual: {total_fee}"

        return result

    except Exception as e:
        result.result = False
        result.score = 0.0
        result.message = f"[Total Fee Check] [FAIL] Unexpected error checking total fee: {str(e)}"
        return result


def check_delivery_duration_estimate(quote_data, submitted_delivery_duration):
    """Verify delivery duration estimate matches"""
    result = ResultStruct()

    if not quote_data:
        result.result = False
        result.score = 0.0
        result.message = "[Delivery Duration Check] [FAIL] Quote data not available"
        return result

    try:
        payment_options = quote_data.get('paymentOptions', [])

        if not payment_options or len(payment_options) == 0:
            result.result = False
            result.score = 0.0
            result.message = "[Delivery Duration Check] [FAIL] No payment options found in quote"
            return result

        first_option = payment_options[0]
        actual_delivery_duration = first_option.get('formattedEstimatedDelivery')

        if actual_delivery_duration is None:
            result.result = False
            result.score = 0.0
            result.message = "[Delivery Duration Check] [FAIL] Delivery duration not found in payment options"
            return result

        if actual_delivery_duration == submitted_delivery_duration:
            result.result = True
            result.score = 1.0
            result.message = f"[Delivery Duration Check] [PASS] Delivery duration matches: {actual_delivery_duration}"
        else:
            result.result = False
            result.score = 0.0
            result.message = f"[Delivery Duration Check] [FAIL] Delivery duration mismatch. " \
                             f"Submitted: {submitted_delivery_duration}, Actual: {actual_delivery_duration}"

        return result

    except Exception as e:
        result.result = False
        result.score = 0.0
        result.message = f"[Delivery Duration Check] [FAIL] Unexpected error checking delivery duration: {str(e)}"
        return result


def check_recipient(recipient_id):
    """Verify that recipient exists"""
    result = ResultStruct()

    if not recipient_id:
        result.result = False
        result.score = 0.0
        result.message = "[Recipient Check] [FAIL] Submitted Recipient ID is empty"
        return result

    try:
        url = f"{API_BASE_URL}/v2/accounts/{recipient_id}"
        headers = {
            'Authorization': f'Bearer {API_TOKEN}'
        }
        response = requests.get(url, headers=headers, timeout=10)

        if response.status_code == 200:
            result.result = True
            result.score = 1.0
            result.message = f"[Recipient Check] [PASS] Recipient {recipient_id} exists"
        else:
            result.result = False
            result.score = 0.0
            result.message = f"[Recipient Check] [FAIL] Failed to fetch recipient: " \
                             f"API returned status code {response.status_code} with message {response.text}"

        return result

    except Exception as e:
        result.result = False
        result.score = 0.0
        result.message = f"[Recipient Check] [FAIL] Unexpected error checking recipient: {str(e)}"
        return result


def check_transfer(transfer_id):
    """Verify that transfer exists"""
    result = ResultStruct()

    if not transfer_id:
        result.result = False
        result.score = 0.0
        result.message = "[Transfer Check] [FAIL] Submitted Transfer ID is empty"
        return result, None

    try:
        url = f"{API_BASE_URL}/v1/transfers/{transfer_id}"
        headers = {
            'Authorization': f'Bearer {API_TOKEN}'
        }
        response = requests.get(url, headers=headers, timeout=10)

        if response.status_code == 200:
            transfer_data = response.json()
            result.result = True
            result.score = 1.0
            result.message = f"[Transfer Check] [PASS] Transfer {transfer_id} exists"
            return result, transfer_data
        else:
            result.result = False
            result.score = 0.0
            result.message = f"[Transfer Check] [FAIL] Failed to fetch transfer: " \
                             f"API returned status code {response.status_code} with message {response.text}"
            return result, None

    except Exception as e:
        result.result = False
        result.score = 0.0
        result.message = f"[Transfer Check] [FAIL] Unexpected error checking transfer: {str(e)}"
        return result, None


def check_transfer_status(transfer_data):
    """Check 8: Verify transfer status is outgoing_payment_sent"""
    result = ResultStruct()

    if not transfer_data:
        result.result = False
        result.score = 0.0
        result.message = "[Transfer Status Check] [FAIL] Transfer data not available"
        return result

    try:
        status = transfer_data.get('status')

        if status is None:
            result.result = False
            result.score = 0.0
            result.message = "[Transfer Status Check] [FAIL] Status not found in transfer data"
            return result

        if status == 'outgoing_payment_sent':
            result.result = True
            result.score = 1.0
            result.message = f"[Transfer Status Check] [PASS] Transfer status is: {status}"
        else:
            result.result = False
            result.score = 0.0
            result.message = f"Transfer status is incorrect. Expected: outgoing_payment_sent, Got: {status}"

        return result

    except Exception as e:
        result.result = False
        result.score = 0.0
        result.message = f"[Transfer Status Check] [FAIL] Unexpected error checking transfer status: {str(e)}"
        return result


def run_custom_checker(t_obj, r_obj):
    """Main checker function that runs checks"""

    print(t_obj)

    # Read data from test case input file
    input_data = read_input_data(t_obj.testcase_input_path)

    if not input_data:
        r_obj.result = False
        r_obj.score = 0.0
        r_obj.message = "Failed to read test case input file"
        return

    # Extract input parameters
    # TODO - need to understand exact format of input file and how data is stored there
    profile_id = input_data.get('profile_id')
    quote_id = input_data.get('quote_id')
    recipient_id = input_data.get('recipient_id')
    transfer_id = input_data.get('transfer_id')
    receive_amount = input_data.get('receive_amount')
    fx_rate = input_data.get('fx_rate')
    total_fee = input_data.get('total_fee')
    delivery_duration_estimate = input_data.get('delivery_duration_estimate')

    # Run all checks
    results = []

    # Check 1: Quote check
    quote_result, quote_data = check_quote(profile_id, quote_id)
    results.append(quote_result)

    # Check 2: Receive amount check
    receive_amount_result = check_receive_amount(quote_data, receive_amount)
    results.append(receive_amount_result)

    # Check 3: Exchange rate check
    fx_rate_result = check_exchange_rate(quote_data, fx_rate)
    results.append(fx_rate_result)

    # Check 4: Total fee check
    total_fee_result = check_total_fee(quote_data, total_fee)
    results.append(total_fee_result)

    # Check 5: Delivery duration check
    delivery_duration_result = check_delivery_duration_estimate(quote_data, delivery_duration_estimate)
    results.append(delivery_duration_result)

    # Check 6: Recipient check
    recipient_result = check_recipient(recipient_id)
    results.append(recipient_result)

    # Check 7: Transfer check
    transfer_result, transfer_data = check_transfer(transfer_id)
    results.append(transfer_result)

    # Check 8: Transfer status check
    transfer_status_result = check_transfer_status(transfer_data)
    results.append(transfer_status_result)

    # TODO - decide whether split each check into separate HR Test or ran all check in 1 HR test and just report
    #  pass/fail and overall score in output
    # Calculate overall result
    total_checks = len(results)
    passed_checks = sum(1 for r in results if r.result)

    r_obj.result = (passed_checks == total_checks)
    r_obj.score = passed_checks / total_checks if total_checks > 0 else 0.0
    r_obj.message = '\n'.join([x.message for x in results])


# End of BODY


# Start of TAIL
class TestStruct:
    def __init__(self):
        self.testcase_id = 0
        self.testcase_input_path = ""
        self.testcase_output_path = ""
        self.testcase_expected_output_path = ""
        self.metadata_file_paths = []
        self.submission_code_path = ""
        self.testcase_result = False
        self.testcase_signal = 0
        self.testcase_time = 0.0
        self.testcase_memory = 0
        self.data = ""


class ResultStruct:
    def __init__(self):
        self.result = False
        self.score = 0.0
        self.message = ""


def read_input_json(json_file_path, t_obj):
    file_obj = open(json_file_path, 'r')
    json_file_contents = file_obj.read()

    root = {}
    try:
        root = json.loads(json_file_contents)
    except ValueError:
        return 1

    try:
        # Read values
        t_obj.testcase_id = root["testcase_id"]
        t_obj.testcase_input_path = root["input_file_path"]
        t_obj.testcase_output_path = root["output_file_path"]
        t_obj.testcase_expected_output_path = root["expected_output_file_path"]
        t_obj.metadata_file_paths = root["metadata_file_paths"]
        t_obj.submission_code_path = root["submission_code_path"]
        t_obj.testcase_result = root["testcase_result"]
        t_obj.testcase_signal = root["testcase_signal"]
        t_obj.testcase_time = root["testcase_time"]
        t_obj.testcase_memory = root["testcase_memory"]
        t_obj.data = root["data"]
    except KeyError:
        return 1

    return 0


def write_result_json(r_obj):
    root = {
        "custom_result": int(r_obj.result),
        "custom_score": max((r_obj.score if (r_obj.score <= 1.0) else 1.0), 0),
        "custom_message": r_obj.message if (len(r_obj.message) <= 4096) else r_obj.message[0:4095]
    }

    print(json.dumps(root))


if __name__ == '__main__':
    # Input parameters
    t_obj = TestStruct()
    # Result parameters
    r_obj = ResultStruct()

    if len(sys.argv) < 2:
        write_result_json(r_obj)
        sys.exit(1)

    # Decode input JSON
    failure = read_input_json(sys.argv[1], t_obj)
    # Incase input JSON was malformed or not existent
    if failure != 0:
        r_obj.message = "Unable to read input json"
        write_result_json(r_obj)
        sys.exit(2)

    # Run the custom checker evaluator
    run_custom_checker(t_obj, r_obj)

    # Encode result JSON
    write_result_json(r_obj)
    sys.exit(0)
# End of TAIL
